---
date: 2023-05-08 00:00:00
layout: post
title: API 디자인과 프로세스 간 통신
subtitle: Domain Driven Design
description: 프로세스 간 통신(Inter-process communication, IPC)
image: https://res.cloudinary.com/dvqcvocet/image/upload/v1683088696/m8krc7ci1vzzbl7sxeac.png
optimized_image: https://res.cloudinary.com/dvqcvocet/image/upload/v1683088696/m8krc7ci1vzzbl7sxeac.png
category: docker
tags:  
  - API디자인
  - 프로세스간통신
  - 동기
  - 비동기
  - 메시지브로커
  - REST_API
  - JSON
author: Hoonology
paginate: true
---

# API 디자인과 프로세스 간 통신

## 프로세스 간 통신
마이크로서비스 간의 통신이 아닌, 프로세스 간 통신 : <u> 마이크로서비스는 하나의 프로세스 단위 </u> 로 실행 된다.

- '서비스 - 서비스'간 통신에서는 인터페이스(Interface)가 존재, 그것의 요구에 따른 소통이 필요하다.
- REST API

## 동기 / 비동기
- HTTP 프로토콜 : TCP 또는 UDP 연결을 생성, 요청에 따라 <u>즉시 응답</u>이 오는 형태로 구현 = '**동기적인 응답** 제공'
- HTTP는 컴퓨터와 컴퓨터 사이의 네트워크 통신이고, 이는 네트워크 지연에 따라 즉시 응답이 오지 않을 수도 있기 때문에 이를 **비동기**로 인식할 수 있다.
  - 하지만 프로세스 간 통신의 관점에서 HTTP는 동기적인 메커니즘으로 분류한다. 
  - 어쨌든 서로 통신하는 두 컴퓨터는 모두 켜져 있어야 하며, 클라이언트는 서버가 제 때 응답을 줄 것이라고 기대하기 때문이다.

|서비스| 작업|
|---|---|
|동기 | 요청/응답|
|비동기| 비동기 요청/응답 (단방향 알림 - 푸시 알림 등) |

## 일대일 및 일대다 통신
뉴스레터 구독 서비스는 1:1로 커뮤니케이션하지 않고 구독자 모두에게 동일한 메시지를 제공하는 형태, 즉 일대다 커뮤니케이션 방식을 취한다.
- HTTP가 일대일인지, 일대다 통신인지 파악하고자 한다면, 요청/응답으로 이뤄진 한 번의 트랜잭션에서 서버는 여러 클라이언트에게 동시에 응답을 전달하지 않는다.
   - 서버가 여러 클라이언트를 상대할 수는 있지만, 그것은 단순 여러 번의 1:1 커뮤니케이션
   - 즉, **일대일 통신이다.**

## 프로세스 간의 직/간접 연결
'클라이언트' - '서버' 아키텍처에서 직접 연결을 구현
- 중간에 메시지 자체를 관리하는 연결 방식 존재 -> 비동기 처리, 메시지를 주고 받을 수 있다.


## JSON( JavaScript Object Notation )
데이터 교환을 위해 만들어진 객체 형태의 포맷  

- 전송 가능한 조건 (transferable condition)

  - 수신자(reciever)와 발신자(sender)가 같은 프로그램을 사용한다.
  - 문자열처럼 범용적으로 읽을 수 있어야 한다.

### 직렬화(serialize), 역직렬화(deserialize) - stringfy, parse
- `JSON.stringify` : Object type을 JSON으로 변환합니다.

```js
let transferableMessage = JSON.stringify(message)
console.log(transferableMessage)  // `{"sender":"김민지","receiver":"박민수","message":"민수야 오늘 저녁 같이 먹을래?","createdAt":"2022-11-11 10:10:10"}`
console.log(typeof(transferableMessage)) // `string`
```


- `JSON.parse` : JSON을 Object type으로 변환
```js
let packet = `{"sender":"김코딩","receiver":"박해커","message":"해커야 오늘 저녁 같이 먹을래?","createdAt":"2021-01-12 10:10:10"}`

let obj = JSON.parse(packet)
console.log(obj)
/*
 * {
 * sender: "김민지",
 * receiver: "박민수",
 * message: "민수야 오늘 저녁 같이 먹을래?",
 * createdAt: "2022-11-11 10:10:10"
 * }
 */
 console.log(typeof(obj))
 // `object`
 ```
![input](/assets/img/MicroService/ser_des.png)



| | 자바스크립트 Object | JSON |
|---|---|---|
| 키 | 키는 따옴표 없이 쓸 수 있음 | 반드시 큰 따옴표를 붙여야 함|
|문자열 값 | 문자열 값은 어떠한 형태의 따옴표도 사용 가능하다 | 반드시 큰 따옴표로 감싸야함|

> JSON은 키와 값 사이, 그리고 키-값 쌍 사이에는 공백이 있어서는 안 됨


## Action 
- JSON 이전에 주로 사용하던 데이터 교환 포맷으로는 XML이 있습니다. JSON이 XML 보다 유리한 점이 무엇인가요?
  - 더 간단하고 가벼움: JSON은 XML보다 더 간단하고 가벼운 형식이므로 더 쉽게 읽고 파싱
  - 더 빠른 구문 분석: JSON은 XML과 같은 종료 태그 및 속성이 필요하지 않기 때문에 XML보다 구문 분석이 더 빠릅니다.
  - 기본 지원: JSON은 대부분의 최신 프로그래밍 언어에서 기본적으로 지원되므로 코드에서 데이터를 보다 쉽게 ​​사용하고 조작할 수 있습니다.
  - 웹 API에 적합: JSON은 XML보다 구문 분석이 쉽고 네트워크 트래픽이 적기 때문에 웹 API에 더 적합합니다.

- JSON 포맷은 텍스트 형식으로, VS Code와 같은 텍스트 에디터에서 읽을 수 있습니다. 반면 텍스트 에디터로 읽을 수 없는 바이너리(이진) 형식의 데이터 교환 포맷(예를 들어 protobuf)도 있습니다. 텍스트 형식의 데이터 교환 포맷과 이진 형식의 데이터 교환 포맷의 차이점과 장단점은 무엇인가요?
  - 장점
    - 더 작은 크기: 이진 형식은 일반적으로 텍스트 기반 형식보다 크기가 작기 때문에 전송 시간이 더 빠르고 네트워크 트래픽이 더 적을 수 있습니다.
    - 더 효율적: 바이너리 형식은 구문 분석 및 변환할 필요 없이 메모리로 직접 읽을 수 있으므로 구문 분석 및 작업에 더 효율적입니다.
    - 더 안전함: 바이너리 형식은 더 쉽게 암호화하거나 압축할 수 있으므로 텍스트 기반 형식보다 더 안전할 수 있습니다.
    - 성능 향상: 바이너리 형식은 더 빠른 처리 시간과 더 낮은 메모리 오버헤드를 제공할 수 있기 때문에 성능이 중요한 응용 프로그램에서 자주 사용됩니다.

  - 단점
    - 가독성이 떨어짐: 이진 형식은 텍스트 편집기에서 쉽게 보거나 편집할 수 없기 때문에 텍스트 기반 형식보다 가독성이 낮고 작업하기 어렵습니다.
    - 플랫폼에 따라 다름: 이진 형식은 플랫폼에 따라 다를 수 있습니다. 즉, 서로 다른 시스템이나 아키텍처에서 제대로 작동하지 않을 수 있습니다.
    - 상호 운용성이 낮음: 바이너리 형식은 특수 라이브러리나 작업 도구가 필요할 수 있으므로 텍스트 기반 형식보다 상호 운용성이 낮을 수 있습니다.
    - 사람이 읽을 수 있는 메타데이터 부족: 이진 형식에는 사람이 읽을 수 있는 메타데이터가 부족한 경우가 많기 때문에 문제를 디버깅하거나 해결하기가 더 어렵습니다.


# 동기식 요청/응답 통신 REST
## REST
HTTP로 소통하는 프로세스 간 통신 규약
- REST API : 웹에서 사용되는 데이터나 리소스를 HTTP URI로 표현, HTTP 프로토콜을 통해 요청과 응답을 정의하는 방식

> HTTP 메시지의 **Body 부분을 JSON**의 형태로 다루고, HTTP **헤더**의 **Content-Type**의 값은 `application/json` 의 형태로 설정한다.

### REST의 장점과 단점 
#### 장점
- 포스트맨, curl 등의 도구로 간편하게 테스트 가능
- 요청/응답 통신을 직접 지원
- 시스템 아키텍처가 단순

#### 단점
- 요청/응답만 지원
- 메시지를 주고 받을 떄 '클리언트'-'서버' 프로세스가 **둘 다 실행**이 되어야함 
- 요청 한 번으로 여러 리소스를 조회하기 어렵다
- 메서드만으로는 한 번의 요청을 통해 이루어지는 다양한 작업들을 대표하기 어렵다

# 메시지 브로커를 이용한 비동기식 통신
- '동기적 방법' : 요청을 보내는 즉시 수신자로 부터 응답이 오길 기대하는 방법
  - REST
- '비동기적 방법' : 요청을 일단 보내놓고 수신자가 받을 때 까지 보관했다가 처리하는 방법
  - 수신자가 받기 전 까지 누군가는 메시지를 보관 -> 메시지 브로커(메시지 큐)

## 메시지 브로커가 필요한가?
- 분산 애플리케이션의 장점 : 분산 애플리케이션에서 **프로세스 간의 느슨한 결합**(loosely coupled)을 제공하는 것  
( **메시지 브로커가 한 시스템의 장애가 다른 시스템에 주는 영향을 줄이도록 한다.** )
   - 일시정인 장애가 발생해도 복구 기간 동안 메시지 브로커가 메시지를 보관하여 데이터 유실을 막을 수 있다. 

![loosely](/assets/img/MicroService/Loosely.png)

- 강하게 결합된 시스템의 단점 : 서로 연결되어 있는 시스템 중 한 곳에서 장애가 발생했을 때 그 장애가 연결된 다른 시스템들에 영향

![tight](/assets/img/MicroService/Tightly.png)

## 메시지 브로커의 특징
- 프로그램 간의 직접 연결이 없다.
  - 소비자 프로세스(메시지를 받는 사람)가 죽어있어도 생산자(메시지를 보내는 사람)는 메시지를 보낼 수 있음
  - 생산자 프로세스가 죽어있어도 소비자는 메시지를 수신할 수 있음
- 메시지 브로커에 있는 메시지는 소비자가 꺼낼 떄 까지 안전하게 보관된다.
  - 메시지는 소비하기 전 까지 사라지지 않는다.
  - 프로그램 간 통신은 시간과 독립적이다.
- 통신이 이벤트에 의해 구동될 수 있다
  - 큐의 상태에 따라 프로그램을 제어할 수 있다.
- 확장에 용이하다
  - 메시지 브로커는 여러 큐를 만들거나 수평 확장하여 메시지 부하 증가를 처리할 수 있다.

## 메시지 브로커의 단점
- 프로세스 간의 직접 연결에 비해 **아키텍처가 복잡**

## 메시지 브로커 선택의 기준
- 종류 : Apache Kafka, Amazon Kinesis, Amazon SQS 
- 선택 기준 
  - 프로그래밍 언어 지원 여부
  - 메시징 표준 지원 여부
  - 메시지 순서 보장 여부
  - 전달 보장 여부: 어떤 종류의 전달을 보장하는가?
  - 영속성: 브로커가 고장 나도 문제가 없도록 메시지가 디스크에 저장되는가?
  - 내구성: 소비자가 메시지 브로커에 다시 접속할 경우, 접속이 중단된 시간에 전달된 메시지를 받을 수 있는가?
  - 확장성
  - 지연 시간

