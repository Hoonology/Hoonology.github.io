---
date: 2023-05-08 00:00:00
layout: post
title: API 디자인과 프로세스 간 통신
subtitle: API 디자인과 프로세스 간 통신
description: 프로세스 간 통신(Inter-process communication, IPC)
image: https://res.cloudinary.com/dvqcvocet/image/upload/v1683088696/m8krc7ci1vzzbl7sxeac.png
optimized_image: https://res.cloudinary.com/dvqcvocet/image/upload/v1683088696/m8krc7ci1vzzbl7sxeac.png
category: docker
tags:  
  - API디자인
  - 프로세스간통신
  - 동기
  - 비동기
  - 메시지브로커
  - REST_API
  - JSON
  - kafka
  - Amazon SQS
  - Amazon Kinesis
author: Hoonology
paginate: true
---

# 1. API 디자인과 프로세스 간 통신

## 프로세스 간 통신
마이크로서비스 간의 통신이 아닌, 프로세스 간 통신 : <u> 마이크로서비스는 하나의 프로세스 단위 </u> 로 실행 된다.

- '서비스 - 서비스'간 통신에서는 인터페이스(Interface)가 존재, 그것의 요구에 따른 소통이 필요하다.
- REST API

## 동기 / 비동기
- HTTP 프로토콜 : TCP 또는 UDP 연결을 생성, 요청에 따라 <u>즉시 응답</u>이 오는 형태로 구현 = '**동기적인 응답** 제공'
- HTTP는 컴퓨터와 컴퓨터 사이의 네트워크 통신이고, 이는 네트워크 지연에 따라 즉시 응답이 오지 않을 수도 있기 때문에 이를 **비동기**로 인식할 수 있다.
  - 하지만 프로세스 간 통신의 관점에서 HTTP는 동기적인 메커니즘으로 분류한다. 
  - 어쨌든 서로 통신하는 두 컴퓨터는 모두 켜져 있어야 하며, 클라이언트는 서버가 제 때 응답을 줄 것이라고 기대하기 때문이다.

|서비스| 작업|
|---|---|
|동기 | 요청/응답|
|비동기| 비동기 요청/응답 (단방향 알림 - 푸시 알림 등) |

## 일대일 및 일대다 통신
뉴스레터 구독 서비스는 1:1로 커뮤니케이션하지 않고 구독자 모두에게 동일한 메시지를 제공하는 형태, 즉 일대다 커뮤니케이션 방식을 취한다.
- HTTP가 일대일인지, 일대다 통신인지 파악하고자 한다면, 요청/응답으로 이뤄진 한 번의 트랜잭션에서 서버는 여러 클라이언트에게 동시에 응답을 전달하지 않는다.
   - 서버가 여러 클라이언트를 상대할 수는 있지만, 그것은 단순 여러 번의 1:1 커뮤니케이션
   - 즉, **일대일 통신이다.**

## 프로세스 간의 직/간접 연결
'클라이언트' - '서버' 아키텍처에서 직접 연결을 구현
- 중간에 메시지 자체를 관리하는 연결 방식 존재 -> 비동기 처리, 메시지를 주고 받을 수 있다.


# 2. 대표적인 데이터 교환 포맷 'JSON'
데이터 교환을 위해 만들어진 객체 형태의 포맷  

- 전송 가능한 조건 (transferable condition)

  - 수신자(reciever)와 발신자(sender)가 같은 프로그램을 사용한다.
  - 문자열처럼 범용적으로 읽을 수 있어야 한다.

### 직렬화(serialize), 역직렬화(deserialize) - stringfy, parse
- `JSON.stringify` : Object type을 JSON으로 변환합니다.

```js
let transferableMessage = JSON.stringify(message)
console.log(transferableMessage)  // `{"sender":"김민지","receiver":"박민수","message":"민수야 오늘 저녁 같이 먹을래?","createdAt":"2022-11-11 10:10:10"}`
console.log(typeof(transferableMessage)) // `string`
```


- `JSON.parse` : JSON을 Object type으로 변환

```js
let packet = `{"sender":"김코딩","receiver":"박해커","message":"해커야 오늘 저녁 같이 먹을래?","createdAt":"2021-01-12 10:10:10"}`

let obj = JSON.parse(packet)
console.log(obj)
/*
 * {
 * sender: "김민지",
 * receiver: "박민수",
 * message: "민수야 오늘 저녁 같이 먹을래?",
 * createdAt: "2022-11-11 10:10:10"
 * }
 */
 console.log(typeof(obj))
 // `object`
 ```

![input](/assets/img/MicroService/ser_des.png)



| | 자바스크립트 Object | JSON |
|---|---|---|
| 키 | 키는 따옴표 없이 쓸 수 있음 | 반드시 큰 따옴표를 붙여야 함|
|문자열 값 | 문자열 값은 어떠한 형태의 따옴표도 사용 가능하다 | 반드시 큰 따옴표로 감싸야함|

> JSON은 키와 값 사이, 그리고 키-값 쌍 사이에는 공백이 있어서는 안 됨


## Actions I
- JSON 이전에 주로 사용하던 데이터 교환 포맷으로는 XML이 있습니다. JSON이 XML 보다 유리한 점이 무엇인가요?
  - 더 간단하고 가벼움: JSON은 XML보다 더 간단하고 가벼운 형식이므로 더 쉽게 읽고 파싱
  - 더 빠른 구문 분석: JSON은 XML과 같은 종료 태그 및 속성이 필요하지 않기 때문에 XML보다 구문 분석이 더 빠릅니다.
  - 기본 지원: JSON은 대부분의 최신 프로그래밍 언어에서 기본적으로 지원되므로 코드에서 데이터를 보다 쉽게 ​​사용하고 조작할 수 있습니다.
  - 웹 API에 적합: JSON은 XML보다 구문 분석이 쉽고 네트워크 트래픽이 적기 때문에 웹 API에 더 적합합니다.

- JSON 포맷은 텍스트 형식으로, VS Code와 같은 텍스트 에디터에서 읽을 수 있습니다. 반면 텍스트 에디터로 읽을 수 없는 바이너리(이진) 형식의 데이터 교환 포맷(예를 들어 protobuf)도 있습니다. 텍스트 형식의 데이터 교환 포맷과 이진 형식의 데이터 교환 포맷의 차이점과 장단점은 무엇인가요?
  - 장점
    - 더 작은 크기: 이진 형식은 일반적으로 텍스트 기반 형식보다 크기가 작기 때문에 전송 시간이 더 빠르고 네트워크 트래픽이 더 적을 수 있습니다.
    - 더 효율적: 바이너리 형식은 구문 분석 및 변환할 필요 없이 메모리로 직접 읽을 수 있으므로 구문 분석 및 작업에 더 효율적입니다.
    - 더 안전함: 바이너리 형식은 더 쉽게 암호화하거나 압축할 수 있으므로 텍스트 기반 형식보다 더 안전할 수 있습니다.
    - 성능 향상: 바이너리 형식은 더 빠른 처리 시간과 더 낮은 메모리 오버헤드를 제공할 수 있기 때문에 성능이 중요한 응용 프로그램에서 자주 사용됩니다.

  - 단점
    - 가독성이 떨어짐: 이진 형식은 텍스트 편집기에서 쉽게 보거나 편집할 수 없기 때문에 텍스트 기반 형식보다 가독성이 낮고 작업하기 어렵습니다.
    - 플랫폼에 따라 다름: 이진 형식은 플랫폼에 따라 다를 수 있습니다. 즉, 서로 다른 시스템이나 아키텍처에서 제대로 작동하지 않을 수 있습니다.
    - 상호 운용성이 낮음: 바이너리 형식은 특수 라이브러리나 작업 도구가 필요할 수 있으므로 텍스트 기반 형식보다 상호 운용성이 낮을 수 있습니다.
    - 사람이 읽을 수 있는 메타데이터 부족: 이진 형식에는 사람이 읽을 수 있는 메타데이터가 부족한 경우가 많기 때문에 문제를 디버깅하거나 해결하기가 더 어렵습니다.


# 3. 동기식 요청/응답 통신 REST
## REST
HTTP로 소통하는 프로세스 간 통신 규약
- REST API : 웹에서 사용되는 데이터나 리소스를 HTTP URI로 표현, HTTP 프로토콜을 통해 요청과 응답을 정의하는 방식

> HTTP 메시지의 **Body 부분을 JSON**의 형태로 다루고, HTTP **헤더**의 **Content-Type**의 값은 `application/json` 의 형태로 설정한다.

### REST의 장점과 단점 
#### 장점
- 포스트맨, curl 등의 도구로 간편하게 테스트 가능
- 요청/응답 통신을 직접 지원
- 시스템 아키텍처가 단순

#### 단점
- 요청/응답만 지원
- 메시지를 주고 받을 떄 '클리언트'-'서버' 프로세스가 **둘 다 실행**이 되어야함 
- 요청 한 번으로 여러 리소스를 조회하기 어렵다
- 메서드만으로는 한 번의 요청을 통해 이루어지는 다양한 작업들을 대표하기 어렵다

# 4. 메시지브로커를 이용한 비동기식 통신
- '동기적 방법' : 요청을 보내는 즉시 수신자로 부터 응답이 오길 기대하는 방법
  - REST
- '비동기적 방법' : 요청을 일단 보내놓고 수신자가 받을 때 까지 보관했다가 처리하는 방법
  - 수신자가 받기 전 까지 누군가는 메시지를 보관 -> 메시지 브로커(메시지 큐)

## 메시지 브로커가 필요한가?
- 분산 애플리케이션의 장점 : 분산 애플리케이션에서 **프로세스 간의 느슨한 결합**(loosely coupled)을 제공하는 것  
( **메시지 브로커가 한 시스템의 장애가 다른 시스템에 주는 영향을 줄이도록 한다.** )
   - 일시정인 장애가 발생해도 복구 기간 동안 메시지 브로커가 메시지를 보관하여 데이터 유실을 막을 수 있다. 

![loosely](/assets/img/MicroService/Loosely.png)

- 강하게 결합된 시스템의 단점 : 서로 연결되어 있는 시스템 중 한 곳에서 장애가 발생했을 때 그 장애가 연결된 다른 시스템들에 영향

![tight](/assets/img/MicroService/Tightly.png)

## 메시지 브로커의 특징
- 프로그램 간의 직접 연결이 없다.
  - 소비자 프로세스(메시지를 받는 사람)가 죽어있어도 생산자(메시지를 보내는 사람)는 메시지를 보낼 수 있음
  - 생산자 프로세스가 죽어있어도 소비자는 메시지를 수신할 수 있음
- 메시지 브로커에 있는 메시지는 소비자가 꺼낼 떄 까지 안전하게 보관된다.
  - 메시지는 소비하기 전 까지 사라지지 않는다.
  - 프로그램 간 통신은 시간과 독립적이다.
- 통신이 이벤트에 의해 구동될 수 있다
  - 큐의 상태에 따라 프로그램을 제어할 수 있다.
- 확장에 용이하다
  - 메시지 브로커는 여러 큐를 만들거나 수평 확장하여 메시지 부하 증가를 처리할 수 있다.

## 메시지 브로커의 단점
- 프로세스 간의 직접 연결에 비해 **아키텍처가 복잡**

## 메시지 브로커 선택의 기준
- 종류 : Apache Kafka, Amazon Kinesis, Amazon SQS 
- 선택 기준 
  - 프로그래밍 언어 지원 여부
  - 메시징 표준 지원 여부
  - 메시지 순서 보장 여부
  - 전달 보장 여부: 어떤 종류의 전달을 보장하는가?
  - 영속성: 브로커가 고장 나도 문제가 없도록 메시지가 디스크에 저장되는가?
  - 내구성: 소비자가 메시지 브로커에 다시 접속할 경우, 접속이 중단된 시간에 전달된 메시지를 받을 수 있는가?
  - 확장성
  - 지연 시간


## Actions II

- 메시지 브로커의 두 가지 방식인 `Queue 방식`과 `Topic 방식`은 어떤 차이가 있나요?
  - 메시지 브로커의 두 가지 유형은 Queue 방식과 Topic 방식이며 메시지 배포 및 메시지 소비를 처리하는 방식이 다릅니다.  
  **Queue 메서드**에서 메시지는 대기열로 전송되고 **한 소비자만 각 메시지를 받습니다**. 대기열은 메시지가 수신된 순서대로 소비자에게 전달되고 각 메시지가 한 소비자에게만 전달되도록 합니다. 이는 **각 메시지를 한 명의 소비자만 처리해야 하고 메시지 처리 순서가 중요한 시나리오에 유용**합니다.


  - 반대로 **Topic 메서드**를 사용하면 **메시지를 주제**로 보낼 수 있으며 **여러 소비자가 각 메시지를 받을 수 있습니다**. 주제는 구독한 모든 소비자에게 메시지를 배포하고 각 소비자는 메시지 복사본을 독립적으로 처리합니다. 이는 **여러 소비자가 동일한 메시지를 처리해야 하거나 다른 소비자 그룹이 메시지의 다른 하위 집합을 처리해야 하는 시나리오에 유용**합니다.


  - 두 방법의 또 다른 **주요 차이점**은 **메시지 승인을 처리하는 방법**입니다.   
  Queue 메서드에서 소비자는 메시지를 처리한 후 메시지를 확인하여 대기열에서 제거해야 합니다. 이렇게 하면 각 메시지가 정확히 한 번만 처리되고 메시지가 손실되거나 중복되지 않습니다. Topic 방식에서 메시지 확인은 선택 사항이며 일부 소비자가 확인하지 못한 경우에도 여러 소비자에게 메시지를 전달할 수 있습니다. 이것은 Topic 메서드를 더 유연하게 만들지 만 중복 처리 또는 메시지 손실을 피하기 위해 더 신중한 디자인이 필요합니다.


  - 전반적으로 Queue 방법과 Topic 방법 간의 선택은 메시징 시나리오의 특정 요구 사항에 따라 다릅니다. Queue 메서드는 메시지를 한 명의 소비자만 순서대로 처리해야 하는 시나리오에 적합하고 Topic 메서드는 메시지를 여러 소비자가 임의의 순서로 처리할 수 있는 시나리오에 적합합니다.



- 메시지 서비스로는 대표적으로 Apache Kafka와 Amazon SQS, Amazon Kinesis가 있습니다. 각각은 어떤 차이가 있나요?
웹 서비스에서 메시지 브로커(메시지 큐)를 이용해 비동기적인 방법이 활용되는 사례를 하나 이상 찾아보고, 어떻게 활용되는지 설명하세요.
  - Apache Kafka, Amazon SQS 및 Amazon Kinesis는 모두 대량의 데이터를 처리하는 분산되고 확장 가능하며 안정적인 방법을 제공하는 메시지 서비스입니다. 그러나 아키텍처, 기능 및 사용 사례가 다릅니다.


  - Apache Kafka는 높은 처리량의 실시간 데이터 스트리밍에 사용되는 오픈 소스 분산 메시징 시스템입니다. 생산자가 주제에 메시지를 게시하고 소비자가 메시지를 수신하기 위해 해당 주제를 구독하는 게시-구독 모델을 사용합니다. Kafka는 높은 확장성, 내결함성 및 짧은 대기 시간으로 유명합니다. 스트리밍 데이터 처리, 실시간 분석 및 마이크로 서비스 간의 메시징에 일반적으로 사용됩니다.


  - Amazon SQS(Simple Queue Service)는 분산 시스템에서 구성 요소를 분리할 수 있는 완전관리형 메시지 대기열 서비스입니다. 생산자가 메시지를 대기열에 보내고 소비자가 대기열에서 해당 메시지를 검색하는 대기열 기반 모델을 사용합니다. SQS는 가용성, 확장성 및 내구성이 뛰어나도록 설계되었습니다. 일반적으로 비동기 처리, 작업 대기열 및 이벤트 기반 아키텍처에 사용됩니다.


  - Amazon Kinesis는 실시간 데이터 스트리밍 및 처리를 위한 완전 관리형 서비스입니다. 대량의 스트리밍 데이터를 실시간으로 처리할 수 있으며 해당 데이터를 처리하고 분석하는 기능을 제공합니다. Kinesis는 생산자가 지속적으로 데이터를 스트림으로 보내고 소비자가 스트림에서 데이터를 검색하는 스트림 기반 모델을 사용합니다. Kinesis는 확장성과 내구성이 뛰어나고 지연 시간이 짧도록 설계되었습니다. 실시간 데이터 처리, 로그 처리 및 스트리밍 데이터 분석에 일반적으로 사용됩니다.


  - 웹 서비스에서 메시지 브로커와 함께 비동기 방식을 사용하는 것과 관련하여 이미지 처리에 대한 사용자 요청을 받는 웹 서비스를 예로 들어 보겠습니다. 사용자가 이미지를 업로드하면 웹 서비스는 이미지 처리에 필요한 메타데이터가 포함된 메시지를 Apache Kafka와 같은 메시지 브로커에 게시할 수 있습니다. 그런 다음 메시지 브로커는 이미지를 비동기식으로 처리할 하나 이상의 작업자 서비스에 메시지를 발송할 수 있습니다.


  - 작업자 서비스는 메시지 브로커에서 메시지를 대기열에서 빼고 요청된 이미지 처리를 수행한 다음 결과 또는 상태 업데이트를 메시지 브로커의 새 메시지로 대기열에 넣을 수 있습니다. 그런 다음 웹 서비스 또는 사용자는 이러한 메시지를 사용하여 이미지 처리의 결과 또는 상태 업데이트를 검색할 수 있습니다.


  - 메시지 브로커와 함께 비동기식 메서드를 사용하면 웹 서비스가 장기 실행 작업을 백그라운드 프로세스로 오프로드하고 확장성을 개선하며 대기 시간을 줄여 더 나은 사용자 경험을 제공할 수 있습니다. 또한 전체 시스템 아키텍처나 성능에 영향을 주지 않고 필요에 따라 더 많은 작업자 서비스를 추가하여 웹 서비스를 수평으로 확장할 수 있습니다.