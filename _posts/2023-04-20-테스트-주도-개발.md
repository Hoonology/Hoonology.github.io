---
date: 2023-04-20 01:30:30
layout: post
title: 테스트 주도 개발
subtitle: 테스트 주도 개발이란
description: 테스트가 기능의 디자인을 주도하는 반복적인 개발 방법론(기존의 개발 프로세스와의 차이)
image: https://res.cloudinary.com/dvqcvocet/image/upload/v1681954803/eoe0iiqoeiq9ghldrltc.png
optimized_image: https://res.cloudinary.com/dvqcvocet/image/upload/v1681954803/eoe0iiqoeiq9ghldrltc.png 
category: CICD
tags:
  - 테스트 주도 개발
  - TDD
  

  
author: Hoonology
comments: true

---

## CI/CD 에서 내가 이용한 아키텍처를 설명할 때! Honey Tip
너의 아키텍쳐에 왜 이걸 썼어? 라고 물어볼 때 가장 설득력 있는 답변은 '**비용**'이다.
> 대표님 제가 그 돈 아껴드릴게요 -> 어떤 인프라를 구성해서 비용 절감 -> 내 연봉 UP

# 테스트 주도 개발
***Test Driven Development, TDD***  
테스트가 기능의 디자인을 주도하는 반복적인 개발 방법론

## 기존 개발 프로세스 vs 테스트 주도 개발 프로세스

### 기존의 개발 프로세스( Test Last )

![dev](/assets/img/CICD/DEV.png)

1. 요구사항 분석
2. 요구 사항을 토대로 디자인(설계) 진행
3. 설계에 맞춰 기능 개발
4. 구현 후 **수동**으로 기능 **테스트**
5. 원하는 대로 동작하지 않거나 문제가 발생하면 **디버깅**을 통해 원인을 파악하고 수정
6. 3-4 과정 반복 후 개발 완료

## Action
Q. 기존 개발 프로세스에는 어떠한 문제가 있었을까요?  

**기존 개발 프로세스**에서는 **테스트 코드를 먼저 작성하는 TDD**와 달리,   
**코드를 먼저 작성하고 그 후에 테스트를 수행하는 방식**이 일반적이었다.  
이 방식은 몇가지 문제점이 있다.  



1. **결함 발견**이 **늦어지는 문제**: 코드 작성 후에 테스트를 수행하면, 결함이 발생한 경우 이를 발견하고 수정하는 데에 더 **많은 시간과 비용**이 들어갑니다.

2. **코드 변경** 시 **불확실성** 문제: 이미 작성된 코드에 대한 변경이 필요한 경우, 이러한 변경이 다른 부분에 어떤 영향을 미칠지 불확실한 경우가 있습니다.

3. **코드 리팩토링의 어려움**: 기존 코드에 대한 리팩토링이 필요한 경우, 이를 수행할 때 기존 코드의 동작을 변경하지 않는 것이 중요합니다. 하지만 **코드를 먼저 작성하고 테스트를 나중에 수행**하는 방식에서는 이를 **보장하기 어려울 수 있습니다**.



> TDD는 이러한 문제점을 해결하기 위해, 테스트 코드를 먼저 작성하고 이를 기반으로 코드를 작성하는 방식입니다. 이를 통해 결함 발견을 조기에 수행하고, 코드 변경 시 불확실성을 줄이며, 코드 리팩토링을 보다 쉽게 수행할 수 있습니다.


### 테스트 주도 개발 과정( Test Driven Development, TDD )

![dev](/assets/img/CICD/TDD.png)

1. 요구사항 분석
2. 요구사항을 토대로 디자인(설계) 진행
3. 설계를 기반으로 기능 테스트 진행
  - 실패 시 다시 설계
4. 테스트가 성공하면 개발 진행
5. 3-4 의 과정 반복 

## Action 
Q. TDD는 기존 개발 프로세스의 문제점을 어떻게 해결해 주었을까요?  

- ```설계 → 개발 → 테스트```로 이어지던 **기존의 개발 프로세스**를 ```설계 → 테스트 → 개발```의 프로세스로 변경하여 **버그를 조기에 발견하고 해결**할 수 있게 되었습니다.
- TDD의 설계 → 테스트 → 개발의 프로세스는 변경 점에 따라 테스트를 진행해야 하는 상황에 대한 부담을 줄여 주었습니다.

## 테스트 주도 개발 사이클
![cycle](/assets/img/CICD/cycle.png)

TDD의 테스트는 큰 단위의 문제를 작은 단위로 나누어, 지속적인 피드백을 통해 목표를 개선해 나가는 방향으로 진행된다.


## TDD의 장점
- 더욱 **명확한 기능과 구조를 설계**할 수 있습니다.
- **재사용성**이 고려된, **모듈화된 코드**를 작성할 수 있습니다.
- **설계 수정 시간과 디버깅 시간의 단축**
  - 단위 테스트 기반의 테스트 코드를 작성하기 때문에 추후 프로그램에 문제가 발생할 경우, 각각의 모듈별로 테스트를 진행하면서 문제 지점을 쉽게 찾아낼 수 있습니다.
- **완성도 높은 설계**
  - 코드의 기능, 정의 등 구조적인 문제에 대하여 명확하게 접근할 수 있으며 다양한 예외상황에 대해서도 고려하게 되므로 이는 완성도 높은 설계로 이어집니다.
- **유지 보수의 용이성**
  - 프로젝트에 어떤 기능을 추가하는 등의 유지 보수를 해야 하는 상황이라면 항상 기존 코드들에 끼칠 영향에 대해 생각해야 합니다.
  - TDD 이전의 개발 방식에선 단순한 기능이라도 수정되거나, 추가되는 경우에는 많은 코드에 대하여 테스트를 진행해야 했으나, TDD를 진행한다면 변경 점에 따른 테스트를 진행해야 하는 상황에 대한 부담이 줄어들 수 있습니다.

  
# 테스트 종류
**TDD**에 활용할 수 있는 테스트의 종류

## 단위 테스트
- 작은 단위의 테스트
- **검증이 필요한 코드에 대해 테스트 케이스를 작성하는 프로세스**
- 예시
    ```js
    // 만일 sum(x, y) 와 같이 두 숫자를 더하는 함수를 테스트하려면,

    it('sum에 두 수를 인자로 입력하면, 두 수의 합이 리턴됩니다', () => {
      expect(sum(1,1)).to.be.equal(2)    // sum(1,1)의 리턴값은 2가 될 것이라고 기대한다
      expect(sum(100, 200)).to.be.equal(300)
    })
    ```

## 통합 테스트
모듈을 통합하는 과정에서 **모듈 간 호환성의 문제를 찾아내기 위해 수행되는 테스트**
- 예시
  ```js
  // 서버에 API 요청을 보냈을 때, 정확한 응답이 오리라고 기대하는 경우
  // 아래의 코드가 백엔드 입장에서는 단순 유닛 테스트라고 볼 수도 있지만
  // 서버와 클라이언트 코드가 별도로 작성되어 있고, 서버-클라이언트의 통합을 테스트해야 한다면, 이는 통합 테스트라고 할 수 있습니다.

  it('서버에 POST /upper 요청에 body를 실어 보내면 응답은 대문자로 돌려줍니다', () => {
    return request(API서버)
      .post('/upper')
      .send('"mYnaMEiS"')
      .set('Content-Type', 'application/json')
      .then(res => {
        expect(res.body).to.be.equal('MYNAMEIS')
      })
  })
  ```

### 단위 테스트 및 통합 테스트 할 때 사용되는 도구
- mocha, chai (JavaScript)
- JUnit (Java)


## E2E 테스트 (End To End Test)
- 전체 시스템이 제대로 동작하는지 확인하기 위한 테스트입니다.
- 사용자의 입장에서 사용자가 사용하는 상황을 가정하고 시뮬레이션을 진행합니다.

### 장점
- 실제 상황에서 발생할 수 있는 에러를 사전에 발견할 수 있습니다.

### 단점
- 테스트 작성 시 들어가는 비용이 너무 많습니다.
- 수행 속도가 느립니다.
- "실패했다"라는 결과만 있기 때문에 피드백의 질이 낮습니다.

### E2E 테스트 시 사용하는 도구
Cypress
Nightwatch
TestCafe