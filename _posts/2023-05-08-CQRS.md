---
date: 2023-05-08 01:00:00
layout: post
title: CQRS
subtitle: CQRS
description: Command Query Responsibility Segregation(명령과 조회의 책임 분리)
image: https://res.cloudinary.com/dvqcvocet/image/upload/v1683088696/m8krc7ci1vzzbl7sxeac.png
optimized_image: https://res.cloudinary.com/dvqcvocet/image/upload/v1683088696/m8krc7ci1vzzbl7sxeac.png
category: docker
tags:  
  - CQRS
  - kafka
  - SQS
  - Kinesis
author: Hoonology
paginate: true
---

# CQRS
- Command Query Responsibility Segregation(명령과 조회의 책임 분리)
- '명령을 처리하는 책임'과 '조회를 처리하는 책임'을 **분리**하는 것
  - 명령은 상태를 변경하는 작업
  - 조회는 상태를 반환하는 작업

## CQRS 마이크로서비스에 적용
- 마이크로서비스의 핵심 : 서비스별 데이터 저장소를 각기 다르게 채택
- 문제점
  - 서비스 성능 향상을 위해서 인스턴스를 스케일 아웃하여 여러 개로 실행할 경우 빈번한 명령과 조회 작업으로 리소스 교착상태가 발생

  - 통상적으로 명령보다 조회 요청이 훨씬 많이 사용되기 때문에, 하나의 서비스 내에 이러한 모든 기능을 넣어두면, 조회 요청 빈도가 증가함에 따라 명령기능도 함께 확장해야 하기 때문에 도메인의 복잡도가 높아짐

- 해결방안
  - **CQRS 패턴 사용** 
    - 기존에 하나의 데이터 저장소에 CRUD 작업을 모두 처리했다면, CQRS는 요청을 크게 명령(Create, Update, Delete)과 조회(Read)로 나누어 처리한다.

- 모델을 나누는 형태로 명령과 조회를 분리한다.( 기존 마이크로서비스 설계 철학과 부합하는 것은 아니다. )
![img](/assets/img/MicroService/CQRS.png)
- 아예 물리적으로 명령 작업과 조회 작업을 위한 저장소를 따로 준비
  -  이처럼 명령과 조회를 각각 분리하면 명령(쓰기) 요청의 부하를 줄이고, 조회 대기 시간을 줄이는 등 다양한 이점을 누릴 수 있다.


![img](/assets/img/MicroService/CQRS2.png)

- 이벤트 소싱 패턴과 함께 사용
> 기본적으로 앞서 살펴본 메시지 브로커를 이용한 이벤트 주도의 아키텍처의 경우, 이벤트로 인해 상태가 변경된 경우, 이를 데이터 모델로 처리하고 최종값을 반영하는 형태를 의미합니다. 하지만 이벤트 소싱 패턴의 경우, 이를 데이터로 저장하는 것이 아니라 상태 변경 이벤트 자체를 저장하는 기법을 의미합니다.

![img](/assets/img/MicroService/CQRS3.png)

# 퀴즈
#### 1. 메시지 서비스로는 대표적으로 ```Apache Kafka```와 ```Amazon SQS```, ```Amazon Kinesis```가 있습니다. 각각은 어떤 차이가 있나요?

> Apache Kafka, Amazon SQS 및 Amazon Kinesis는 **모두 대량의 데이터를 처리하는 분산되고 확장 가능하며 안정적인 방법을 제공하는 메시지 서비스**입니다. 그러나 아키텍처, 기능 및 사용 사례가 다릅니다.

> `Apache Kafka`는 높은 처리량의 실시간 데이터 스트리밍에 사용되는 **오픈 소스 분산 메시징 시스템**입니다. 생산자가 주제에 메시지를 게시하고 소비자가 메시지를 수신하기 위해 해당 주제를 구독하는 '**게시-구독 모델**'을 사용합니다. **Kafka는 높은 확장성, 내결함성 및 짧은 대기 시간**으로 유명합니다. 스트리밍 데이터 처리, 실시간 분석 및 마이크로 서비스 간의 메시징에 일반적으로 사용됩니다.

> `Amazon SQS`(Simple Queue Service)는 분산 시스템에서 구성 요소를 분리할 수 있는 **완전관리형 메시지 대기열 서비스**입니다. 생산자가 메시지를 대기열에 보내고 소비자가 대기열에서 해당 메시지를 검색하는 '**대기열 기반 모델**'을 사용합니다. **SQS는 가용성, 확장성 및 내구성이 뛰어나도록 설계**되었습니다. 일반적으로 비동기 처리, 작업 대기열 및 이벤트 기반 아키텍처에 사용됩니다.

> `Amazon Kinesis`는 **실시간 데이터 스트리밍 및 처리**를 위한 **완전 관리형 서비스**입니다. 대량의 스트리밍 데이터를 실시간으로 처리할 수 있으며 해당 데이터를 처리하고 분석하는 기능을 제공합니다. Kinesis는 생산자가 **지속적으로 데이터를 스트림으로 보내고 소비자가 스트림에서 데이터를 검색**하는 **스트림 기반 모델**을 사용합니다. **Kinesis는 확장성과 내구성이 뛰어나고 지연 시간이 짧도록 설계**되었습니다. 실시간 데이터 처리, 로그 처리 및 스트리밍 데이터 분석에 일반적으로 사용됩니다.

세 가지 서비스 모두 메시징 기능을 제공하지만 **Apache Kafka는 실시간 데이터 스트리밍 및 메시징에 적합**하고 **Amazon SQS는 비동기식 처리 및 작업 대기열에 적합**하며 **Amazon Kinesis는 실시간 데이터 스트리밍 및 처리용으로 설계**되었습니다. 서비스 선택은 사용 사례의 특정 요구 사항에 따라 다릅니다.

Apache Kafka, Amazon Kinesis는 아키텍처, 기능 및 사용 사례가 다르다.


#### 2. 웹 서비스에서 메시지 브로커(메시지 큐)를 이용해 비동기적인 방법이 활용되는 사례를 하나 이상 찾아보고, 어떻게 활용되는지 설명하세요.


> 웹 서비스에서 **메시지 브로커와 함께 비동기식 메서드를 사용**하는 한 가지 예는 **보고서 생성, 데이터 분석 또는 복잡한 계산 수행과 같은 장기 실행 작업에 대한 사용자 요청을 처리**하는 것입니다. <u>사용자가 작업이 완료될 때까지 기다리게 하는 대신 웹 서비스는 요청을 메시지 브로커의 메시지로 대기열에 넣은 다음 사용자에게 작업이 수락되었고 비동기식으로 처리될 것이라는 응답을 반환</u>할 수 있습니다.


> 그런 다음 메시지 브로커는 요청을 **비동기적으로 처리할 작업자 서비스 또는 작업자 서비스 그룹에 메시지를 발송**할 수 있습니다. 작업자 서비스는 메시지 브로커에서 메시지를 대기열에서 빼고 요청된 작업을 수행한 다음 결과 또는 상태 업데이트를 메시지 브로커의 새 메시지로 대기열에 넣을 수 있습니다. 그런 다음 웹 서비스 또는 <u>사용자는 이러한 메시지를 사용하여 작업의 결과 또는 상태 업데이트를 검색할 수 있습니다.</u>


> 예를 들어 **재무 보고서**에 대한 데이터 분석을 제공하는 웹 서비스는 Apache Kafka 또는 Amazon SQS와 같은 메시지 브로커를 사용하여 보고서 생성 요청을 받을 수 있습니다. **사용자가 보고서 요청을 제출**하면 **웹 서비스는 보고서에 필요한 매개 변수를 포함하는 메시지 브로커의 주제에 메시지를 게시**할 수 있습니다. 그러면 **작업자 서비스 그룹이 해당 주제를 구독하고 보고서 요청을 비동기적으로 처리**할 수 있습니다. 작업자 서비스는 생성된 보고서를 파일이나 데이터베이스에 쓴 다음 요청의 완료 상태와 생성된 보고서의 위치를 ​​나타내는 메시지를 다른 주제에 게시할 수 있습니다. 그런 다음 웹 서비스 또는 사용자는 해당 메시지를 사용하여 생성된 보고서 또는 요청 상태를 검색할 수 있습니다.


> 메시지 브로커와 함께 비동기식 메서드를 사용하면 웹 서비스가 장기 실행 작업을 백그라운드 프로세스로 오프로드하고 확장성을 개선하며 대기 시간을 줄여 더 나은 사용자 경험을 제공할 수 있습니다.


